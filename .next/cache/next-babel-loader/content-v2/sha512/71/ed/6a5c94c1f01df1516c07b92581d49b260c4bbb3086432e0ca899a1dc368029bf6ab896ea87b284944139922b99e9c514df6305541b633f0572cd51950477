{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { url } from \"src/utils/url\";\nimport { AXIOS } from \"./config\";\nimport { parseError } from \"./errors\";\n\nclass RepositoryService {\n  constructor() {\n    _defineProperty(this, \"client\", AXIOS);\n  }\n\n  async listRepositories(_) {\n    try {\n      const res = await this.client.get(url.REPOS); // for (const item of res.data.items) {\n      //   item.value = item.name;\n      // }\n\n      res.data.items.forEach(item => item.value = item.name);\n      return {\n        _items: res.data.items,\n        _range: {\n          total: 4,\n          limit: 10,\n          offset: 0\n        }\n      };\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n\n  async getRepository(req) {\n    try {\n      const uri = encodeURIComponent(req.id);\n      const res = await this.client.get(url.REPOS + `/${uri}`);\n      return res.data.info;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n\n  async createRequestRepo(req) {\n    try {\n      const res = await this.client.post(url.REQUEST_REPOS, req);\n      return res.data;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n\n  async ApproveRequest(req) {\n    try {\n      const res = await this.client.post(url.RPC_REPOS + `/${req.id}/approve`);\n      return res === null || res === void 0 ? void 0 : res.data;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n\n  async getRequest(req) {\n    try {\n      const res = await this.client.get(url.REQUEST_REPOS + `/${req.id}`); // console.log(\"res\", res);, res);\n\n      return res === null || res === void 0 ? void 0 : res.data.info;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n\n  async RejectRequest(req) {\n    try {\n      const res = await this.client.post(url.RPC_REPOS + `/${req.id}/reject`, {\n        reviewer_comment: req.reason\n      }); // console.log(\"res\", res);, res);\n\n      return res === null || res === void 0 ? void 0 : res.data;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n\n}\n\nconst NewRepositoryService = () => new RepositoryService();\n\nexport default NewRepositoryService;","map":{"version":3,"sources":["/Users/140457/Documents/Study/CNM/cnm-crypto-wallet/src/services/api/repositories.ts"],"names":["url","AXIOS","parseError","RepositoryService","listRepositories","_","res","client","get","REPOS","data","items","forEach","item","value","name","_items","_range","total","limit","offset","err","getRepository","req","uri","encodeURIComponent","id","info","createRequestRepo","post","REQUEST_REPOS","ApproveRequest","RPC_REPOS","getRequest","RejectRequest","reviewer_comment","reason","NewRepositoryService"],"mappings":"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","sourcesContent":["import { Metadata } from \"src/utils/types\";\nimport { url } from \"src/utils/url\";\nimport { AXIOS } from \"./config\";\nimport { parseError } from \"./errors\";\n\nexport type Repository = {\n  readonly id: string;\n  readonly name: string;\n  readonly description?: string;\n  readonly state?: string;\n  readonly parent?: string;\n  readonly created_at: string;\n  readonly updated_at: string;\n  value?: string;\n  permissions?: any;\n  readonly reviewer_comment?: string;\n  // readonly inheriting?: {\n  //   id: string;\n  //   name: string;\n  // };\n  // readonly branches?: Array<{\n  //   id: string;\n  //   name: string;\n  //   revision: string;\n  // }>;\n};\n\nexport type RepoRequest = {\n  readonly repo: string;\n  readonly reason: string;\n  readonly description?: string;\n  readonly parent?: string;\n  readonly reviewer?: string;\n  readonly request_user?: string;\n  readonly status?: \"OPEN\" | \"REJECTED\" | \"APPROVED\";\n  readonly created_at?: string;\n  readonly updated_at?: string;\n  id?: string;\n  readonly inheriting?: {\n    id: string;\n    name: string;\n  };\n  readonly branches?: Array<{\n    id: string;\n    name: string;\n    revision: string;\n  }>;\n};\n\nexport type ListRepositoriesRequest = {};\nexport type ListRepositoriesResponse = {\n  _items: Repository[];\n  _range: Metadata;\n};\nexport type GetRepositoryRequest = {\n  id: string | string[] | undefined;\n};\nexport type GetRepositoryResponse = Repository;\n\nexport type GetLogsRepositoryRequest = {};\nexport type GetLogsRepositoryResponse = any;\nexport type RequestRepoRequest = {\n  readonly repo: string;\n  readonly reason?: string;\n};\nexport type createRequestRepoResponse = { code: number; id: string };\nexport type ApproveRequestResponse = { code: number };\ntype ApproveRequestRequest = {\n  id: string | string[] | undefined;\n};\n\nexport type GetRequestRequest = {\n  id: string | string[] | undefined;\n};\nexport type GetRequestResponse = RepoRequest;\nexport type RejectRequestResponse = { code: number };\ntype RejectRequestRequest = {\n  id: string | string[] | undefined;\n  reason: string;\n};\ninterface IRepositoryService {\n  listRepositories(\n    _: ListRepositoriesRequest\n  ): Promise<ListRepositoriesResponse>;\n  getRepository(req: GetRepositoryRequest): Promise<GetRepositoryResponse>;\n  createRequestRepo(\n    req: RequestRepoRequest\n  ): Promise<createRequestRepoResponse>;\n  ApproveRequest(req: ApproveRequestRequest): Promise<ApproveRequestResponse>;\n  getRequest(_: GetRequestRequest): Promise<GetRequestResponse>;\n  RejectRequest(req: RejectRequestRequest): Promise<RejectRequestResponse>;\n}\n\nclass RepositoryService implements IRepositoryService {\n  private readonly client = AXIOS;\n\n  async listRepositories(\n    _: ListRepositoriesRequest\n  ): Promise<ListRepositoriesResponse> {\n    try {\n      const res: any = await this.client.get(url.REPOS);\n      // for (const item of res.data.items) {\n      //   item.value = item.name;\n      // }\n      res.data.items.forEach((item: Repository) => (item.value = item.name));\n      return {\n        _items: res.data.items,\n        _range: {\n          total: 4,\n          limit: 10,\n          offset: 0,\n        },\n      };\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n\n  async getRepository(\n    req: GetRepositoryRequest\n  ): Promise<GetRepositoryResponse> {\n    try {\n      const uri = encodeURIComponent(req.id as string);\n      const res: any = await this.client.get(url.REPOS + `/${uri}`);\n      return res.data.info as GetRepositoryResponse;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n\n  async createRequestRepo(\n    req: RequestRepoRequest\n  ): Promise<createRequestRepoResponse> {\n    try {\n      const res = await this.client.post(url.REQUEST_REPOS, req);\n      return res.data as createRequestRepoResponse;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n  async ApproveRequest(\n    req: ApproveRequestRequest\n  ): Promise<ApproveRequestResponse> {\n    try {\n      const res: any = await this.client.post(\n        url.RPC_REPOS + `/${req.id}/approve`\n      );\n      return res?.data as ApproveRequestResponse;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n  async getRequest(req: GetRequestRequest): Promise<GetRequestResponse> {\n    try {\n      const res: any = await this.client.get(url.REQUEST_REPOS + `/${req.id}`);\n      // console.log(\"res\", res);, res);\n      return res?.data.info as GetRequestResponse;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n  async RejectRequest(\n    req: RejectRequestRequest\n  ): Promise<RejectRequestResponse> {\n    try {\n      const res: any = await this.client.post(\n        url.RPC_REPOS + `/${req.id}/reject`,\n        { reviewer_comment: req.reason }\n      );\n      // console.log(\"res\", res);, res);\n      return res?.data as RejectRequestResponse;\n    } catch (err) {\n      throw parseError(err);\n    }\n  }\n}\n\nconst NewRepositoryService = (): IRepositoryService => new RepositoryService();\n\nexport default NewRepositoryService;\n"]},"metadata":{},"sourceType":"module"}